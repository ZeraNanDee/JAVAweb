application.yaml比起application.properties的优势在于，可以直接绑定pojo层的属性和值，方便设置全局环境。
在Company类中注入 @ConfigurationProperties(prefix = "company") ，根据对应的属性值，在application.yaml中绑定赋值即可。

JRS303验证是后台验证，前端验证可能被绕过执行，因为前后端都需要签证。@Validated加在实体类上

根据不同的开发环境，配置文件也可能不同，例如application.properties和application-test.properties。在默认的application.properties当中，
加上Spring.profiles.active=test，这样就更改成了application-test.properties文件。yaml的话就将不同环境通过---进行分割，不需要多个配置文件。
pring: 
  profiles: 
    active: test

@SpringBootApplication集成了自动装配，扫描bean以及项目包，tomcat等，更加便利。 
所有类最终都配置在SpringFactoriesLoader类中的  public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories 中
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(HttpProperties.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass(CharacterEncodingFilter.class)
@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true)
HttpEncodingAutoConfiguration 一个这样的类都需要以上相关注解完成，才能在 application.properties 中可以调用。

自动装配的两个核心。
xxxxAutoConfiguration:自动装配类：给容器中添加组件
xxxxProperties:封装配置文件中相关属性；
application.properties中配置 debug = true 可以查看已经自动装配好的工具和还没装配的。

静态资源装配：WebMvcAutoConfiguration和WebMvcProperties 指定了路径 WEB/INF/webjars/** 或者 /** , 静态资源如果在项目中的话，相同文件名
优先级：resource目录 > static目录 > 其他路径  一般静态资源访问的目录：static resource public /** webjars

如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面e79fa5e98193e4b893e5b19e31333363393730，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。

pojo类中的注解：@Data @AllArgsConstructor @NoArgsConstructor 无需写setter getter 和构造函数。
