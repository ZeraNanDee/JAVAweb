SpringIOC实例化都是通过JAVA的反射机制实现

JAVA的反射机制就是允许我们动态调用某个对象的方法/构造函数，获取某个对象的属性等，
而无需再编码时确定调用的对象，也就是不需要自己在编码时new出来，而是类编译加载时JVM自动创建实例。
Class c=Class.forName（“类的路径”）
Object action=c.newInstance（）;//加载类，调用无参默认的构造函数
c.getMethod（）/C.getField（）....可以获取对象c的方法/构造函数，获取某个对象的属性等（包括私有）

private static ApplicationContext applicationContext;这个类是Spring IOC容器的使用
    ApplicationContext（上下文管理）是由BeanFactory（工厂类管理）派生而来，是其子类，多了一些方法，例如：
	1.ApplicationContext有多了监控和事件机制，ContextRefreshedEvent：bean全部类加载完，
	有相关相应事件，同时更容易看出bean文件配置错误，bean生命周期的启动停止销毁
	2.利用MessageSource进行国际化  
	3.底层资源的访问 ，扩展了ResourceLoader(资源加载器)接口，从而可以用来加载多个Resource
	4.对Web应用的支持  
  
  new 是java中的关键字，是创建一个新对象的关键字，面向对象编程，是静态实例
  而newInstance（）是通过反射机制实例一个对象，用于面向接口编程,javaweb的spring中常用的静态实例化方法，newInstance() 是java反射框架中类对象(Class)创建新对象的方法,
  方法签名：Object java.lang.Class.newInstance();如:  
  Class clazz = String.class;     Object newInstance = clazz.newInstance();
  编译时反射将寻找的对象直接实例化，如果不存在此对象，编译也可以通过，而new关键字就不行，必须先指明要实例化的对象。
  newInstance()也经常见于工厂设计模式中，在该模式中，共产类的该方法返回一个工厂bean。
  
  bean的id和name的区别就是id必须唯一不能有相同id，否则报错，而name可以同名，但配置文件中允许出现两个name相同的<bean>，
  在用getBean()返回实例时，后面一个Bean被返回,应该是前面那个<bean>被后面同名的 <bean>覆盖了。
  
  <bean id="itemf" class="cn.itcareers.m03.ItemFactory" /> 是个普通的Bean；
<bean id="item" factory-bean="itemf" factory-method="getItem" />是工厂Bean。
普通的Bean返回的是一个实例。工厂Bean返回的不是一个实例，而是由工厂getItem方法返回的对象，作为工厂方法返回的实例，它将使用容器创建的bean。
Bean工厂有静态的，Bean工厂的管理机制就是用bean管理bean，最开始实例化bean工厂，之后每次调用只需要更改bean工厂中的bean的值，而不需要再实例化。

JVM：1.加载.class文件 2.管理并分配内存 3.执行垃圾收集 JRE包含JVM的运行环境，是JAVA程序运行的容器，同时也是操作系统的
一个进程，JVM在整个JDK中处于最底层，负责于操作的交互，用来屏蔽操作系统环境，提供独特的运行环境，JVM通过JDK的java.exe完成，
JVM就是JAVA可以运用于多平台的一个重要原因。

Spring配置文件的整合，如果导入多个XML文件，可以再另外做一个XML作为这些XML的整合，在主方法中只需要调用整合的XML即可


Spring使用外部属性文件:
--添加命名空间：<beans>中添加context Schema定义（xmlns:context="http://www.springframework.org/schema/context"）
--在配置文件下加入配置：<context:property-placeholder location="classpath:db.properties"/>
<!-- 导入属性文件 -->  
<context:property-placeholder location="classpath:db_properties"/>  
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">  
    <property name="user" value="${user}"></property>  
    <property name="password" value="${password}"></property>  
    <property name="driverClass" value="${driverclass}"></property>  
    <property name="jdbcUrl" value="${jdbcurl}"></property>  
</bean>   

Spring表达式语言（简单SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言，
语法类似于EL：SpEL使用#｛...｝作为定界符，所有在大框号中的字符都将被认为是SpEL。
SpEL为bean的属性进行动态赋值提供了便利。

SpEL表达式：字面量
字面量的表示：
---  整数：<property name="count" value="#{5}"/>
---  小数：<property name="frequency" value="#{89.7}"/>
---  科学计数法：<property name="capacity" value="#{1e4}"/>
---  String可以使用单引号或者双引号作为字符串的定界符号：
           <property name="name" value="#{"Chuck"}"/>或<property name="name" value="#{'Chuck'}"/>
---  Boolean：<property name="enabled" value="#{false}"/>

[html] view plain copy print?
<!-- 使用spel为属性赋一个字面值 -->  
<bean id="address" class="com.wul.spring.beans.spel.Address">  
    <property name="city" value="#{'Beijing'}"></property>  
    <property name="street" value="WuDaoKou"></property>  
</bean>  

通过SpEL可以实现：
1.引用其他对象
[html] view plain copy print?
<!-- 使用spel来应用其他的bean -->  
<property name="car" value="#{car}"></property>  

2.引用其他对象的属性
[html] view plain copy print?
<!--使用spel来应用其他的bean的属性 -->  
<property name="city" value="#{address.city}"></property>  

3.调用其他方法，还可以链式操作

4.算数运算符：+ -  *  /  % ^

5.加号还可以用作字符串连接

6.比较运算符：< > == <=  >= lt gt eq le ge 

7.逻辑运算符：and，or，not，|

8.if-else运算符：？: (temary) , ?:(Elvis)
[html] view plain copy print?
<!-- 在spel中使用运算符 -->  
lt;property name="info" value="#{car.price>=300000?'金领':'白领'}"></property>  
9.if-else的变体

10.正则表达式：matches

11.调用静态方法或静态属性：通过T()调用一个类的静态方法，它将返回一个Class Object，然后再调用相应的方法或属性。
[html] view plain copy print?
<!--使用spel引用类的静态属性  -->  
<property name="tyrePerimeter" value="#{T(java.lang.Math).PI*80}"></property>  

使用构造器注入属性值可以指定参数的位置和类型。例如两个构造器参数不同，参数重载了，那么在配置文件中调用时可以用type=“（类型）”区分


